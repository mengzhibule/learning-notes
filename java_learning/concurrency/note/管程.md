---
typora-root-url: image
---

# 管程

## 什么是管程

java采用的是管程技术，sychronized，wait(),notify(),notifyAll()这三个方法都是管程的组成部分。而**管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。**

管程对应的英文是monitor。意译是管程，直译是监视器。

**所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。**

## MESA模型

在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen模型，Hoare模型和MESA模型。

java中采用的是MESA模型。

**互斥：同一时刻只允许一个线程访问共享资源。**

**同步：线程之间如何通信，协作。**

### 互斥

思路：将共享变量及其对共享变量的操作统一封装起来。

如下图：

管程对共享变量queue这个队列和相关操作入队，出队都封装起来；

线程A和线程B要想访问queue,只能通过调用管程提供的enq().deq()来实现

enq,dep保证互斥性，只允许一个线程进入管程。

![img](/线程间互斥原理.png)

### 同步

在管程模型里，共享变量和对共享变量的操作都是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。

管程里还引入了条件变量的概念，而且每个条件变量都对应一个等待队列。

条件变量A和B都有自己的等待队列。

![img](/线程间同步原理.png)

条件变量和等待队列的作用就是解决同步问题。

线程T1执行出队操作，出队操作的条件是队列不为空，如果为空，队列不为空这个条件变量就去它对应的等待队列里等待，调用notempty.wait()，

线程T2执行入队操作，之前队列不空这个条件对于线程t1已经满足了，此时t2要通知t1，告诉它需要的条件已经满足了。当线程t1得到通知，就会从等待队列里出来，但是出来后不是马上执行，而是重新进入到入口等待队列里面。调用notempty.notifyAll();

```java
public class BlockedQueue<T>{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队:如果队列已满，就需要等待直到队列不满
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满 
        notFull.await();
      }  
      // 省略入队操作...
      // 入队后, 通知可出队，队列不空notempty对应的等待队列
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队：如果队列为空，就需要等待直到队列不空
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      // 出队后，通知可入队 队列不满对应的等待队列
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}

```

## 使用wait()

MESA模型特有的：

```java
while(条件不满足) {
  wait();
}
```

## 模型之间的区别

Hasen模型，Hoare模型和MESA模型的一个核心区别是当条件满足后，如何通知相关线程。

管程要求同一时刻只允许一个线程执行，那当线程T2的操作使T1等待的条件满足时，t1和t2究竟谁可以执行：

1. Hasen模型：要求notify()放在代码的最后，这样T2通知完T1后，T2就可以结束了，T1再执行。
2. Hoare模型：T2通知完T1后，T2阻塞，T1马上执行；等T1执行完，在唤醒T2，T2多了一次阻塞唤醒操作。
3. MESA模型：T2通知完T1后，T2继续执行，T1并不立即执行，仅仅是从条件变量的等待队列进到入口队列里面。这样做的好处是notify()不用放到代码的最后，T2也没有多余的阻塞唤醒操作。缺点：T1再次执行的时候，可能曾经满足的条件现在已经不满足了，需要以循环的方法检验条件变量。

## notify()

1. 所有等待线程都拥有相同的等待条件
2. 所有等待线程被唤醒后，执行相同的操作
3. 只需要唤醒一个线程

