## 创建线程的步骤

new Thread();

1. 堆内存分配一块内存
2. 调用操作系统内核API,然后操作系统要为线程分配一系列的资源。

线程是一个重量级的对象，应该避免频繁创建和销毁。

一般池化资源，当你需要资源的时候就调用acquire()方法来申请资源，用完之后就调用release()释放资源。

但是线程池里没有这些步骤。

## 线程池介绍

java线程的实现是采用生产者-消费者模式。线程池的使用方是生产者，线程池本身是消费者。

自定义线程池实现代码：

```java
// 简化的线程池，仅用来说明工作原理
class MyThreadPool{
  // 利用阻塞队列实现生产者 - 消费者模式
  BlockingQueue<Runnable> workQueue;
  // 保存内部工作线程
  List<WorkerThread> threads 
    = new ArrayList<>();
  // 构造方法
  MyThreadPool(int poolSize, 
    BlockingQueue<Runnable> workQueue){
    this.workQueue = workQueue;
    // 创建工作线程
    for(int idx=0; idx<poolSize; idx++){
      WorkerThread work = new WorkerThread();
      work.start();
      threads.add(work);
    }
  }
  // 提交任务
  void execute(Runnable command){
    workQueue.put(command);
  }
  // 工作线程负责消费任务，并执行任务
  class WorkerThread extends Thread{
    public void run() {
      // 循环取任务并执行
      while(true){ ①
        Runnable task = workQueue.take();
        task.run();
      } 
    }
  }  
}

/** 下面是使用示例 **/
// 创建有界阻塞队列
BlockingQueue<Runnable> workQueue = 
  new LinkedBlockingQueue<>(2);
// 创建线程池  
MyThreadPool pool = new MyThreadPool(
  10, workQueue);
// 提交任务  
pool.execute(()->{
    System.out.println("hello");
});

```

## java中的线程池

ThreadPoolExecutor：

```java
ThreadPoolExecutor(
  int corePoolSize,
  int maximumPoolSize,
  long keepAliveTime,
  TimeUnit unit,
  BlockingQueue<Runnable> workQueue,
  ThreadFactory threadFactory,
  RejectedExecutionHandler handler) 

```

* corePoolSize:表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要保留corePoolSize个人坚守阵地。

* maximumPoolSize：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制的加，最多久只能加到maximumPoolSize个人。

* keepAliveTime&unit：项目组可以根据忙闲来增减人员，那在编程世界里，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime和unit就是用来定义这个一段时间的参数。也就是说，如果线程已经空闲了keepAliveTime和unit这么久了，而且线程数大于corePoolSize，那么这个空闲线程就要被回收。

* workQueue：和上面实例代码的工作队列同义。

* threadFactory：通过这个参数可以自定义如何创建线程。

* handler:通过这个参数可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，可以通过这个参数来指定

  ThreadPoolExecutor已经提供了四种策略。

  1. CallerRunsPolicy:提交任务的线程自己去执行该任务。
  2. AbortPolicy:默认的拒绝策略，会throws RejectedExecutionException.
  3. DiscardPolicy:直接丢弃任务，没有任何异常输出。
  4. DiscardOldestPolicy:丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。

## 注意：

考虑到ThreadPoolExecutor的构造函数实现有些复杂，所以java提供了一个线程池的静态工厂类，Executors，利用Executors可以快速创建线程池。

但是大厂都不建议使用Executors，原因：

Executors的很多方法默认使用的是无界的LinkedBlockQueue，高负载情况下，无界队列很容易导致OOM。而OOM了就会导致所有请求都无法处理。**强烈建议使用有界队列。**

使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会throw RejectedExecutionException这个运行时异常，所以开发人员很容易忽略。

因此默认拒绝策略需要慎重使用。

如果线程处理的任务非常重要，建议自定义拒绝策略，实际开发中，自定义拒绝策略往往和降级策略配合使用。

使用线程池，还需要注意异常处理的问题，通过ThreadPoolExecutor对象的execute()方法执行任务时，如果在任务执行期间出现运行时异常，会导致任务的线程终止，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽说线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获异常信息，并按需处理。



