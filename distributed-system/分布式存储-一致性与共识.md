# 一致性与共识（Consistency）

## 一致性模型

### 线性一致性（Linearizability）

别名：原子一致性（Atomic Consistency）、强一致性（Strong Consistency）、立即一致性（Immediate Consistency）和外部一致性（External Consistency）

常见应用场景：分布性锁、Leader 选举、唯一性约束

* 对于写操作来说，任意两个写操作 x1 和 x2：

  * 如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；

  * 如果写 x1 操作在写 x2 开始前完成，那么 x2 一定覆盖 x1。

* 对于读操作来说：
  * 写操作完成后，所有的客户端都能立即观察到；
  * 对于多个客户端来说，必须读取到一样的顺序。

在线性一致性模型中不论是数据的覆盖顺序还是读取顺序，都是按时间线从旧值向新值移动，而不会出现旧值反转的情况。

### 顺序一致性（Sequential Consistency）

* 对于写操作来说，任意两个写操作 x1 和 x2：
  * 如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；
  * 当写 x1 操作在写 x2 开始前完成，如果两个写操作没有因果关系，当写 x1 操作在写 x2 开始前完成，那么有可能 x1 覆盖 x2，也有可能 x2 覆盖 x1；如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。
* 对于读操作来说：
  * 如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1；
  * 对于多个客户端来说，必须观察到一样的顺序。

### 因果一致性（Causal Consistency）

一种一致性强度低于顺序一致性的模型

* 对于写操作来说，任意两个写操作 x1 和 x2：
  * 如果两个写操作没有因果关系，那么写 x1 操作在写 x2 开始前完成，有的节点是 x1 覆盖 x2，有的节点则 x2 可能覆盖 x1；
  * 如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。
* 对于读操作来说：
  * 如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1。

### 最终一致性（Eventual Consistency）

* 对于同一台机器的两个写操作 x1 和 x2 来说：
  * 如果写 x1 操作在写 x2 开始前完成，那么所有节点在最终某时间点后，都会用 x2 覆盖 x1。
* 对于读操作来说：
  * 在数据达到最终一致性的过程中，客户端的多次观察可以看到的结果是 x1 和 x2 中的任意值；
  * 在数据达到最终一致性的过程后，所有客户端都将只能观察到 x2。

## 一致性与共识的关系

### 共识（Consensus）

在分布式系统中，共识（Consensus）问题是最重要，也是最基本的问题之一，简单来说它就是多个节点（进程）对某一个事情达成一致的结果。

在分布式系统中，我们经常碰到这样的场景，比如在主从复制的模型中，需要在多个节点选举出 Leader 节点。由于有且只能有一个 Leader 节点，所以多个节点必须就哪一个节点是 Leader 这个决定达成一致。

那么共识算法经常用于像选举 Leader 、分布式锁服务这样，有且只有一个能胜出的场景。

### 共识算法必须满足的四个条件

* 一致同意（Uniform Agreement）：所有协议的节点必须同意相同的决议。
* 诚实性（Integrity）：所有节点不能反悔。
* 有效性（Validity）：如果决定了值 v ，则 v 一定是由某个节点所提议的。
* 可终止性（Termination）：如果节点不崩溃，则一定可以达成决议。

一致同意和诚实性定义了共识的核心思想：所有人都决定了相同的结果，并且一旦决定了，就不能再改变。

合法性主要是为了排除没有意义的解决方案。

可终止性确保了，共识算法在部分节点故障的情况下，其他的节点也能达成一致，可终止性让共识算法能够容错。

### 一致性与共识算法的关系

共识算法是手段，一致性是目的，先有共识算法，后有高可用的线性一致性系统。

目前通过共识算法，来实现高可用的线性一致性模型，是一个最常见的选择。

## 事务与共识的关系

事务的原子性一般是通过2PC或者3PC的手段实现。2PC就是一个典型的共识算法的应用场景，所有的参与者都同意，就提交事务；如果有参与者不同意，就中止事务。但是2PC 不是一个完备的共识算法，它满足共识算法的一致同意、诚实性以及合法性，但是在协调者出现故障的时候，并不能满足共识算法的可终止性。

事务的隔离性一般是通过2PL或者MVCC的手段实现。但是他们实现的前提是在底层数据为单副本的基础之上。但是在分布式系统中，为了系统的高可用，底层存储的数据是多副本，为了对事务操作表现出单副本的状态，数据的复制协议必须是线性一致性的，而线性一致性的数据复制协议，通常都是通过共识算法来实现的。

事务为了持久性而引入了数据复制，但是为了保障隔离性，只能选择线性一致性的数据复制算法，而一旦涉及线性一致性，就说明我们又回到共识了。