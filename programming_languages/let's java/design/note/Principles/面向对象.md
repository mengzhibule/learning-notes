# 面向对象编程

* OOP（Object Oriented Programming）面向对象编程
  * 面向对象编程是一种编程范式或者是一种编程风格。它以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四大特性，作为代码设计和实现的基石。
* OOPL（Object Oriented Programming Language）面向对象编程语言
  * java、c ++、go、python、c#、ruby、javascript、objective-c、scala、php、perl。
  * 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现对象编程的四大特性的编程语言。
  * 如果按照严格定义，语法支持面向对象的四大特性的编程语言才是面向对象的编程语言。如果按照不严格的定义，只要某种语言支持类，对象语法机制即可。
* 面向对象编程不一定都是通过使用面向对象编程语言来进行的。

# 面向对象分析和面向对象设计

* OOA（Object Oriented Analysis）面向对象分析
* OOD（Object Oriented Design）面向对象设计
* 我们都是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计。需要哪些类，每个类里需要哪些方法，属性，类与类之间如何交互的。

# 四大特性

## 封装（Encapsulation）

**1.定义：**

信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。需要编程语言提供权限访问控制语法来支持，例如java中的private,public,projected关键字。

**2.作用：**

* 保护数据不会被随意修改，提高代码的可维护性；
* 仅暴露必要的接口，提高类的易用性；

## 抽象（Abstraction）

**1.定义：**

隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要关心方法的具体实现。抽象可以通过接口类或者抽象类来实现。

**2.作用：**

* 提高代码的可扩展性，可维护性，修改实现不需要改变定义，减少代码的改动范围；
* 它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

## 继承（Inheritance）

**1.定义：**

is-a的关系。分为两种模式：单继承，多继承。java是单继承，c++是多继承。

**2.作用：**

* 解决代码复用的问题；

## 多态（Polymorphism）

**1.定义：**

子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。需要编程语言提供特殊的语法机制来实现，如继承，接口类，duck-typing。

**2.作用：**

* 提高代码的扩展性和复用性。
* 是很多设计原则，设计模式，编程技巧的代码实现基础。

# 面向对象代码示例

1. 编写接口类`List`

   ```java
   public interface List<E> {
   	void add(E e);
   	void add(int index, E e);
   	void ensureCapacity();
   	E get(int index);
   	int size();
   	int capacity();
   }
   ```

2. 编写抽象类`AbstractList`

   ```java
   public abstract class AbstractList<E> implements List<E>{
   
   	protected AbstractList(){
   
   	}
   	@Override
   	public void add(E e) {
   		add(size(), e);
   	}
   	protected void checkIndexForAdd(int index) {
   		if (index < 0 || index > size()) {
   			throw new IndexOutOfBoundsException("index is error: " + index);
   		}
   	}
   	protected abstract E[] getDatas();
   	@Override
   	public String toString() {
   		E[] datas = getDatas();
   		StringBuilder builder = new StringBuilder("[");
   		for (int i = 0; i < size(); i++) {
   			builder.append(datas[i]);
   			if (i != size() - 1){
   				builder.append(",");
   			}
   		}
   		builder.append("]\n");
   		return builder.toString();
   	}
   }
   ```

3.  编写实现类`ArrayList`

   ```java
   public class ArrayList<E> extends AbstractList<E>{
   	private E[] datas;
   	private int capacity;
   	protected int size;
   	private int DEFAUL_CAPACITY = 10;
   	public ArrayList() {
   		datas = (E[]) new Object[DEFAUL_CAPACITY];
   		this.capacity = DEFAUL_CAPACITY;
   	}
   	@Override
   	protected E[] getDatas() {
   		return datas;
   	}
   	public ArrayList(int capacity) {
   		datas = (E[]) new Object[capacity];
   		this.capacity = capacity;
   	}
   	@Override
   	public void add(int index, E o) {
   		checkIndexForAdd(index);
   		// 判断容量是否已满
   		if (datas.length == size) {
   			// 扩容
   			ensureCapacity();
   		}
   		// 数据搬移
   		System.arraycopy(datas, index, datas, index + 1, size - index);
   		datas[index] = o;
   		size++;
   	}
   	@Override
   	public void ensureCapacity() {
   		int size = size();
   		int oldCapacity = capacity();
   		int newCapacity = oldCapacity + (oldCapacity >> 1);
   		if (newCapacity > Integer.MAX_VALUE - 8) {
   			newCapacity = Integer.MAX_VALUE - 8;
   		}
   		Object[] newData =  new Object[newCapacity];
   		System.arraycopy(datas, 0, newData, 0, size);
   		datas = (E[])newData;
   	}
   	@Override
   	public E get(int index) {
   		return datas[index];
   	}
   	@Override
   	public int size() {
   		return size;
   	}
   	@Override
   	public int capacity() {
   		return capacity;
   	}
   }
   ```

4. 继承实现类`SortArrayList`

   ```java
   public class SortArrayList<E> extends ArrayList<E>{
   
      @Override
      public void add(int index, E e) {
         ensureCapacity();
         E[] datas = getDatas();
         int i = size - 1;
         while (i >= 0){
            E data = datas[i];
            if(data instanceof Comparable){
               Comparable comp = (Comparable)data;
               String s = comp.toString();
               if(((Comparable)e).compareTo(Integer.valueOf(s)) < 0){
                  datas[i + 1] = datas[i];
               }else{
                  break;
               }
            }else{
               throw new RuntimeException("this element's type is not Comparable!");
            }
   
            i --;
         }
         datas[i + 1] = e;
         ++ size;
      }
   }
   ```

5. 编写测试类`IntegerComparable`和`Test`

   ```java
   public class IntegerComparable implements Comparable<Integer>{
   
   	private Integer value;
   	public IntegerComparable(){
   
   	}
   	public Integer getValue() {
   		return value;
   	}
   	public void setValue(Integer value) {
   		this.value = value;
   	}
   	@Override
   	public int compareTo(Integer o) {
   		return (this.value - o);
   	}
   	@Override
   	public String toString() {
   		return "" + value;
   	}
   }
   
   public class Test {
   	public static void main(String[] args) {
   		List<IntegerComparable> list = new ArrayList<>();
   		Random random = new Random();
   		for (int i = 0; i < 5; i++) {
   			IntegerComparable value = new IntegerComparable();
   			value.setValue(random.nextInt(100));
   			list.add(value);
   		}
   		System.out.println(list.toString());
   		list = new SortArrayList<>();
   		for (int i = 0; i < 5; i++) {
   			IntegerComparable value = new IntegerComparable();
   			value.setValue(random.nextInt(100));
   			list.add(value);
   		}
   		System.out.println(list.toString());
   	}
   
   }
   ```

# 面向对象VS面向过程

**1.什么是面向过程编程？什么是面向过程编程语言？**

* **面向过程编程:**以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法分离。
* **面向过程编程语言**:不支持面向对象的四大特性。

**2.面向对象VS面向过程**

* 对于大规模复杂的程序开发， 程序的处理流程并非单一的一条主线，二是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
* 面向对象编程具备四大特性。利用这些特性，可以使代码易扩展，易复用，易维护。
* 面向对象编程语言比面向过程编程语言更加人性化，更加高级，更加智能。

# 抽象类和接口类

## 抽象类

1. **特性：**

* 抽象类不允许被实例化，只能被继承。
* 抽象类可以包含属性和方法。方法既可以抽象方法，也可以包括实例方法，静态方法。
* 子类继承抽象类，必须实现抽象父类中的所有的抽象方法。

2. **作用：**

* 代码复用
* 如果没有抽象类，在父类中定义一个空的方法实现，影响代码的可读性，如果继承这个父类，可能会忘记重写这个空方法的实现。如果实例化这个父类，可能会调用这个无意义的空实现。

## 接口类

1. **特性：**

* 接口不能包含成员变量，声明的变量默认都是`public static final`修饰的。
* 接口在`jdk1.8`之前默认都是`public abstract`修饰的，在`jdk1.8`之后允许有默认实现，利用`default`关键字修饰。
* 类实现接口的时候，必须实现接口中所有声明的非默认实现的方法。

2. **作用：**

* 解耦
* 接口是对行为的一种抽象，相当于一组协议或者契约。调用者只需要关注抽象的接口，不需要了解具体的实现。
* 接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

is-a使用抽象类

has-a使用接口

# 基于接口而非实现编程

**接口的定义：**

接口就是一组协议或者约定，是功能提供者提供给使用者的一个功能列表。接口在不同的场景下会有不同的解读，比如服务端与客户端之间的接口，类库提供的接口，甚至是一组通信协议都可以叫做接口。

具体到编码，就可以理解为接口类或者抽象类。

**基于接口而非实现编程:**

* 将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游代码基本上不需要改动，降低耦合性，提高扩展性。
* 基于抽象而非实现编程：**越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能在不破坏原有设计的情况下灵活应对。**



# 少用继承多用组合

继承层次过深，过复杂也会影响代码可读性。

表示is-a，支持多态特性，代码复用，可以使用组合，接口，委托三种技术手段来达成。

